---
title: 面经复盘 —— 腾讯会议客户端一面
date: 2024-3-5 15:46:06
categories:
- 面经
mathjax: true
---
腾讯云腾讯会议客户端一面面经。
<!-- more -->
### 1. 自我介绍
### 2. 数据结构中，线性的数据结构介绍一下，都有什么特点？

**常见的九大数据结构**

#### (1) 数组
存储类型相同的元素、在内存中按照先后顺序连续存放
#### (2) 链表
每个节点包含了数据域和指针域，通过指针进行下一个元素的查找和访问

|  | 数组 | 链表 |
| ---------- | ------ | ---------------- |
| 内存地址 | 连续的内存空间 | 非连续的内存空间 |
| 数据长度 | 长度固定，不可动态扩展 | 长度动态可变 |
| 增删效率 | 低，需要移动后面所有元素 | 高，只需要修改指针 |
| 查询效率 | 高，通过数组名和下标访问，复杂度O(1) | 低，只能通过遍历节点，复杂度O(n) |
| 数据访问方式 | 随机访问 | 顺序访问 |

#### (3) 跳表
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="/images/I1_f1.png" width = "50%" alt=""/>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      <!-- figure 1: 套接字通信的文件描述符 -->
  	</div>
</center> 

通过多级索引加快原始链表的查询效率，复杂度O(lgn)。索引级的指针域除了指向下一个索引的指针，还有一个指针指向低一级的链表位置。

#### (4) 栈
本身为线性表，先进后出
#### (5) 队列
先进先出
#### (6) 树
树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。
**完全二叉树**：除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。
**满二叉树**：除了最后一层，其它层的结点都有两个子结点。
**平衡二叉树**：平衡二叉树又被称为AVL树，它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
**二叉排序树**：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。
**树的高度**：结点层次的最大值
**平衡因子**：左子树高度 - 右子树高度
为了保持平衡二叉树的平衡，需要进行调整，有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。 --> AVL的查找效率高O(lgn)，但是插入删除效率低
**红黑树**：
* 每个节点要么是黑的，要么是红的
* 根节点是黑的
* 叶节点是黑的
* 如果一个节点是红的，它的两个儿子是黑的
* 对于任何节点，到叶节点NIL指针的路径包含同样数目的黑节点

#### (7) 堆
对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此可以直接用数组来表示一个堆。
堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。

#### (8) 散列表（哈希表）
一种通过键值对直接访问数据的结构，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。关键在于散列函数定义：
* 直接寻址法：取关键字或者关键字的某个线性函数值作为散列地址
* 数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。
* 平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。
* 取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。
* 除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。
确定好散列函数之后，通过某个key值的确会得到一个唯一的value地址。但是却会出现一些特殊情况。即通过不同的key值可能会访问到同一个地址，这个现象称之为冲突。
**解决冲突的方法**：
* 开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。
* 再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。
* 链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。
* 公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。

#### (9) 图
图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。
邻接矩阵和邻接表（方便求出度）、逆邻接表（方便求入度）、十字链表（合二为一）
在邻接表中，每一个顶点都对应着一条链表，链表中存储的是顶点能够达到的相邻顶点。

### 3. 你了解哈希算法吗？以及哈希表的数据结构
### 4. 哈希算法的时间复杂度
### 5. 设计哈希表需要用到哪些数据结构
### 6. 常见的排序算法介绍一下，以及它们的时间复杂度
冒泡排序、选择排序、插入排序、快速排序、希尔排序、归并排序、堆排序、计数排序、桶排序、基数排序
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="/images/I1_f2.png" width = "50%" alt=""/>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      <!-- figure 1: 套接字通信的文件描述符 -->
  	</div>
</center> 

### 7.	在计算机网络中，常见的TCP/IP协议的协议分层以及对应的每一层协议
### 8.	应用层的HTTP协议你有了解过吗，它的包文内容
### 9.	有了解过HTTP有哪些方法？
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="/images/I1_f3.png" width = "50%" alt=""/>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      <!-- figure 1: 套接字通信的文件描述符 -->
  	</div>
</center> 

HTTP1.0定义了三种请求方法：GET, POST, HEAD
HTTP1.1新增了六种：OPTIONS, PUT, PATCH, DELET, TRACE, CONNECT

方法 | 描述
---- | ----
GET	| 请求指定的页面信息，并返回实体主体。
POST |	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
HEAD |	类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
OPTIONS	| 允许客户端查看服务器的性能。
PUT  |	从客户端向服务器传送的数据取代指定的文档的内容。
PATCH |	是对 PUT 方法的补充，用来对已知资源进行局部更新。
DELET |	请求服务器删除指定的页面。
TRACE |	回显服务器收到的请求，主要用于测试或诊断。
CONNECT |	HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。

状态码 |	具体含义 |	常见的状态码
---------|------------|---------------
1××|	提示信息，表示目前是协议处理的中间状态，还需要后续操作	|
2××|	成功，报文被收到且正确处理|	200，204，206
3××	|重定向，资源位置发生变动，需要客户端重发|	301，302，304
4××	|客户端错误，请求保温有误，服务器无法处理|	400，403，404
5××	|服务器错误，服务器再请求处理时内部错误|	500，501，502，503

常见字段|	含义
---------|------------
Host字段	|发送请求时，指定服务器域名
Content-Length字段	|返回数据时，表明本次的数据长度
Connection字段	|客户端要求使用HTTP长连接机制
Content-Type字段|	用于服务器回应时，告知是什么数据格式
Content-Encoding字段|	说明数据的压缩方法


### 10.	HTTP和HTTPs有什么区别？
### 11.	在数据传输过程中是对称加密还是非对称加密
### 12.	对称加密，密钥从哪里来
### 13.	TCP的可靠性，是如何保证可靠传输的？
* 校验和
* 序列号和确认号
* 确认和重传机制
* 流量控制
* 拥塞控制

### 14.	TCP有建立连接的过程，三次握手是需要同步什么信息？
### 15.	那个序列号为什么如此重要，以及作用是？
同步连接双方的序列号和确认号并交换TCP窗口大小信息
作用：数据的分片和重组、数据传输的可靠性、流量控制（滑动窗口）、防止旧报文段干扰

### 16.	操作系统的物理内存和虚拟内存如何理解？
### 17.	物理内存的逻辑地址是如何映射到物理内存的？
虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。可以把进程所使用的地址「隔离」开。
内存映射：

 | 地址变换过程 | 访问一个逻辑地址的访存次数
 ----------|----------|---------
基本地址变换 | ①算页号、页内偏移量 ②检查页号合法性 ③查页表，找到页面存放的内存块号 ④根据内存块号与页内偏移量得到物理地址 ⑤访问目标内存单元 | 两次访存
具有快表的地址变换 | ①算页号、页内偏移量 ②检查页号合法性 ③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤;若未命中则进行④ ④查页表，找到页面存放的内存块号，并且将页表项复制到快表中 ⑤根据内存块号与页内偏移量得到物理地址 ⑥访问目标内存单元 | 快表命中，只需一次访存 快表未命中，需要两次访存


发现虚拟内存未映射到物理内存，会触发缺页中断。缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。

如果没有空闲的物理内存，那么内核就会开始进行回收内存的工作，回收的方式主要是两种：直接内存回收和后台内存回收。如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——触发 OOM （Out of Memory）机制。
内存回收对象是文件页和匿名页。
**文件页**：回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存。（暂时还没写入磁盘的数据（也就是脏页））
**匿名页**：这部分内存没有实际载体，这部分内存很可能还要再次被访问，所以不能直接释放内存，它们回收的方式是通过 Linux 的 Swap 机制，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。


### 18.	如果在页表中找不到，操作系统会怎么做？
### 19.	操作系统中的进程和线程如何理解的？
### 20.	线程可以共享进程的哪些资源以及是否有自己的独特的资源？
### 21.	多线程访问同一个变量会带来什么问题？如何解决？

 |进程|线程
----------|----------|---------
定义|	资源分配和拥有的基本单位|	程序执行的基本单位
切换情况|	进程CPU环境的保存以及新调度的进程CPU环境的设置	|保存和设置程序计数器、少量寄存器和栈的内容
拥有资源|	CPU资源、内存资源、文件资源和句柄等|	程序计数器、寄存器、栈和状态字
并发性	|不同进程之间切换实现并发，各自占有CPU实现并行|	一个进程内部的多个线程并发执行
系统开销|	切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大	|切换时只需保存和设置少量寄存器内容，因此开销很小
通信方面|进程间通信需要借助操作系统	|线程间可以直接读写进程数据段(如全局变量)来进行通信

### 22.	读写锁的特点
### 23.	死锁是如何产生的以及如何避免？
### 24.	C++的struct和class有什么区别？
相同点
* 两者都拥有成员函数、公有和私有部分
* 任何可以使用class完成的工作，同样可以使用struct完成

不同点
* 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的
* class默认是private继承， 而struct默认是public继承

### 25.	有了解过C++虚函数吗？是用来解决什么问题？
### 26.	编译器是如何实现函数的多态？怎么知道调用父类的虚函数还是子类的虚函数？
### 27.	智能指针你有了解过吗？
智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源
（1）shared_ptr
实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。
（2）unique_ptr
采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。
（3）weak_ptr
弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。
（4）auto_ptr
主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。

### 28.	C++内存管理介绍一下，谈谈你的理解
在C++中，内存分成5个区，他们分别是堆、栈、全局/静态存储区、常量存储区和代码区。
（1）栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
（2）堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
（3）全局/静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。
（4）常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。
（5）代码区，存放程序的二进制代码

### 29.	C++标准库介绍一下
### 30.	容器方面介绍一下
### 31.	算法题：合并两个有序链表
