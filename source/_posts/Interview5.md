---
title: 面经复盘 —— 腾讯云二部一面
date: 2024-3-20 15:46:06
categories:
- 面经
mathjax: true
---
腾讯云二部一面面经。
<!-- more -->

### 1. 项目介绍
### 2. Python包的依赖问题，相同的包不同版本的依赖冲突
虚拟环境？
### 3. MySQL的存储引擎
常见的存储引擎 InnoDB、MyISAM 和 Memory
（1）InnoDB存储引擎
InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），其它存储引擎都是非事务安全表，支持行锁定和外键，MySQL5.5以后默认使用InnoDB存储引擎。
InnoDB特点： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。
（2）MyISAM存储引擎
MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务，不支持外键。
MyISAM特点： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用
（3）MEMORY存储引擎
MEMORY存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。
MEMORY特点： 所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。
它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。
对于InnoDB和MyISAM两个数据库引擎的选择：
1）当需要使用数据库的事务时，InnoDB引擎就是首选。由于锁的粒度小，写操作是不会锁定全表的。所以在并发度较高的场景下使用会提升效率的。
2）大容量的数据集时趋向于选择Innodb。因为它支持事务处理和故障的恢复。Innodb可以利用数据日志来进行数据的恢复。主键的查询在Innodb也是比较快的。
3）如果表的读操作远远多于写操作时，并且不需要事务的支持的。可以将MyIASM作为数据库引擎的首先。
4）大批量的插入语句时（这里是INSERT语句）在MyIASM引擎中执行的比较的快，但是UPDATE语句在Innodb下执行的会比较的快，尤其是在并发量大的时候。
InnoDB和MyISAM引擎所使用的索引的数据结构？都是B+树
对于MyIASM引擎来说，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。
而Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。
### 4. Truncate了解过吗？有什么方式可以把表里数据清空掉？
### 5. 有用过drop table吗？
（1）清空表命令：truncate
SQL语法： truncate table 表名
注意：
1)	不能与where一起使用。
2)	truncate删除数据后是不可以rollback的。
3)	truncate删除数据后会重置Identity（标识列、自增字段），相当于自增列会被置为初始值，又重新从1开始记录，而不是接着原来的ID数。
4)	truncate删除数据后不写服务器log，整体删除速度快。
5)	truncate删除数据后不激活trigger(触发器)。
（2）删除表命令：drop
SQL语法：drop table 表名; drop table if exists 表名;
注意：truncate只会清除表数据，drop不光清除表数据还要删除表结构。
（3）清空数据表指定内容：delet
SQL语法：delete from 表名 where id='1'; delete from 表名;
注意：
delete含义：你要删除哪张表的数据 ?你要删掉哪些行 ?
delete可以删除一行，也可以删除多行；
如果不加where条件，则是删除表所有的数据，这是很危险的！不建议这样做！
【总结】
1、当你不再需要该表时，用 drop;
2、当你仍要保留该表，但要删除所有数据表记录时，用 truncate;
3、当你要删除部分记录或者有可能会后悔的话，用 delete。
### 6. 数据库三大范式？
### 7. 进程和线程的区别？
### 8. 线程之间通信的机制？数据交换的方式？
### 9. 线程有没有独享的内存区域？
### 10. 进程之间的通信方式？
### 11. 同一个机器上的进程可以用socket的方式通信吗？和不同机器的区别是啥？
进程间通信方式：

通信方式 | 具体描述
------|------
管道(pipe)|	允许一个进程和另一个与它有共同祖先的进程之间进行通信
命名管道(FIFO)|	类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建
消息队列(MQ)|	消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点；
信号量(semaphore)	|信号量主要作为进程间以及同进程不同线程之间的同步手段；
共享内存(shared memory)	|它使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥
信号(signal)|	信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身
内存映射(mapped memory)|	内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它
Socket	|它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信

**Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。**

我们来看看创建 socket 的系统调用：int socket(int domain, int type, int protocal)
三个参数分别代表：
**domain 参数**用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；
**type 参数**用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；
**protocal 参数**原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；
**根据创建 socket 类型的不同，通信的方式也就不同：**
**实现 TCP 字节流通信**： socket 类型是 AF_INET 和 SOCK_STREAM；
**实现 UDP 数据报通信**：socket 类型是 AF_INET 和 SOCK_DGRAM；
**实现本地进程间通信**： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；

**线程通信方式：**
Linux:

通信方式 | 具体描述 
----- | ------
	信号 | 	类似进程间的信号处理
	锁机制 | 互斥锁、读写锁和自旋锁
	条件变量 | 使用通知的方式解锁，与互斥锁配合使用
	信号量 | 包括无名线程信号量和命名线程信号量

Windows：

通信方式 | 具体描述 
----- | ------
全局变量 |	需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化
Message消息机制 |	常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。
CEvent对象 |	CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。

### 12. 算法题：实现LRU














