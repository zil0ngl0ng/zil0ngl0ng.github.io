---
title: 面经复盘 —— 腾讯广告工程部一面
date: 2024-3-18 15:46:06
categories:
- 面经
mathjax: true
---
腾讯广告工程部一面面经。
<!-- more -->
### 1. 进程和线程的本质区别？
### 2. 为什么进程切换开销大？
### 3. 切换的时候具体要做哪些工作？
### 4. 线程切换要做哪些事情？
（1）线程为什么比进程切换快？
线程相比进程能减少开销，体现在：
1)	线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
2)	线程的终止时间比进程快，因为线程释放的资源相比进程少很多；
3)	同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
4)	由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；
所以，不管是时间效率，还是空间效率线程比进程都要高。
（2）进程的上下文切换
进程控制块（process control block，PCB）数据结构来描述进程。包括了进程描述信息、进程控制和管理信息、资源分配清单、CPU 相关信息。
进程是由内核管理和调度的，所以进程的切换只能发生在内核态。
所以，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。
通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="/images/I4_f1.png" width = "80%" alt=""/>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      <!-- figure 1: 套接字通信的文件描述符 -->
  	</div>
</center> 
 
（3）线程
线程是进程当中的一条执行流程。同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。
线程与进程最大的区别在于：线程是调度的基本单位，而进程则是资源拥有的基本单位。所以，所谓操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。
线程的切换
i.	当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
ii.	当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；

### 5. 大概讲一下操作系统的内存管理策略
### 6. 详细一点，比如怎么分块的？内存最小单位？
为了在多进程环境下，使得**进程之间的内存地址不受影响，相互隔离**，于是操作系统就为每个进程独立分配一套**虚拟地址空间**，每个程序**只关心自己的虚拟地址**就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。
每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了**大量的进程**，物理内存必然会很紧张，于是**操作系统会通过内存交换技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）**。
那既然有了虚拟地址空间，那必然要把虚拟地址「**映射**」到物理地址，这个事情通常由操作系统来维护。那么对于虚拟地址与物理地址的映射关系，可以有**分段和分页**的方式，同时两者结合都是可以的。
内存分段是根据**程序的逻辑角度**，分成了**栈段、堆段、数据段、代码段**等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的**大小都不是统一**的，这就会导致**外部内存碎片和内存交换效率低**的问题。
于是，就出现了内存分页，把**虚拟空间和物理空间分成大小固定的页**，如在 Linux 系统中，每一页的大小为 4KB。由于分了页后，就不会产生细小的内存碎片，解决了内存分段的外部内存碎片问题。同时**在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率**。
再来，为了解决简单分页产生的**页表过大**的问题，就有了**多级页表**，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，**加大了时间上的开销**。于是根据程序的**局部性原理**，在 CPU 芯片中**加入了 TLB**，负责**缓存最近常被访问的页表项，大大提高了地址的转换速度**。

### 7. 为什么要虚拟内存？
第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。
### 8. 数组和链表的区别，以及各自的特点和适用的场景？
### 9. 数据库基本的ACID概念，讲一下
1)	原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。
2)	一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。
3)	隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。
4)	持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 10.	隔离性一般有几种级别
### 11.	幻读对应哪种级别解决的问题
### 12.	可重复读什么方式保障不会幻读
### 13.	MVCC怎么理解多版本呢？是创建数据要把旧的复制一遍吗？旧版本的记录是存下来的吗？怎么做到多版本？
基于undo_log的版本链
一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：
通过 trx_id 可以知道该记录是被哪个事务修改的；
通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；
**通过 ReadView + undo log 实现 MVCC（多版本并发控制）**
MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。
### 14.	过程型语言的基本特点
### 15.	什么时候会用到多态？
### 16.	使用多态的好处？或者说优势？
封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
多态(Polymorphism)同字面意思意为多种形态，本质就是不同对象完成同一行为产生的不同结果。  
多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。条件：要有继承关系；子类要重写父类的方法；父类引用指向子类对象。
多态的好处？
① 可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。
② 可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。
③ 接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。
④ 灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。
⑤ 简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。

### 17.	编码原则有哪些？（代码）
https://www.zhihu.com/tardis/bd/art/345126462?source_id=1001
<!-- ① 保持简单和直接原则(KISS) Keep it simple, stupid。
在软件开发过程中，把简单作为主要目标，避免做一些没有必要的复杂工作。
② 不需要原则(YAGNI) You Aren’t Gonna Need It
不要写目前用不上，但将来也许需要的代码。在确定真的有必要的时候再写代码，那时再重构也来得及。
③ 避免复制原则(DRY) DRY：Don’t repeat yourself
保证在一个系统内部，任何一个知识点都必须有一个单一的、明确的、权威的陈述。
④ 信息隐藏原则
一段代码调用了另外一段代码，那么调用者不应该知道被调用者的内部实现，否则，调用者就有可能通过修改被调用者的内部实现而完成某个功能，而不是强制要求调用者修改自己的代码。
优点：
1、限制了模块变更的范围
2、如果需要修复缺陷，对其他模块影响最小
3、显著提高模块的可复用性
4、模块具有更高的可测试性
信息隐藏：帮助开发人员找到好的设计模式的原则
封装：依赖于编程语言的技术，用于限制对模块内部的访问
⑤ 高内聚原则
任何软件实体(模块、组件、单元、类、函数等)应该具有很高的内聚性，减少依赖关系。
⑥ 松耦合原则
松耦合可以为系统的各个独立的模块提供高度的自治性。在软件设计中，松耦合的关键就是接口。高内聚会促进低耦合，因为具有明确定义职责的模块，通常会依赖较少的其他模块。
⑦ 小心优化原则
只要没有明确的性能要求，就避免优化。
⑧ 最少惊讶原则(PLA)
不应该让用户对用户界面的意外响应而感到惊讶。调用函数不应该让调用者感到异常行为或一些隐藏的副作用，函数应该完全按照函数名称指示的意义执行。
⑨ 童子军原则
每当在一段代码中发现需要改进的或者风格不好的代码时，应立刻修正，与这段代码的原创作者是谁无关紧要。 -->

### 18. 了解过什么设计模式？用过单例模式吗
https://www.zhihu.com/tardis/bd/art/345126462?source_id=1001
https://zhuanlan.zhihu.com/p/575645658
创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
### 19.	数据结构：二叉树的前序遍历（递归&非递归）
### 20.	算法题：和不小于s的长度最小的连续子数组




